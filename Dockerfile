# --- 阶段 1: 基础镜像 ---
# 使用 Debian/glibc-based 的镜像来保证原生模块的兼容性 (例如 sharp)
FROM node:20-bookworm-slim AS base
WORKDIR /app

# --- 阶段 2: 构建器 ---
FROM base AS builder
# 拷贝 package 文件并安装所有依赖 (包括 devDependencies)
COPY package*.json ./
RUN npm install
# 拷贝所有源代码
COPY . .

# 接收所有从 cloudbuild.yaml 传来的构建参数
ARG _NEXT_PUBLIC_FIREBASE_API_KEY
ARG _NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN
ARG _NEXT_PUBLIC_PROJECT_ID
ARG _NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET
ARG _NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID
ARG _NEXT_PUBLIC_FIREBASE_APP_ID
ARG _NEXT_PUBLIC_VERTEX_API_LOCATION
ARG _NEXT_PUBLIC_GCS_BUCKET_LOCATION
ARG _NEXT_PUBLIC_GEMINI_MODEL
ARG _NEXT_PUBLIC_SEG_MODEL
ARG _NEXT_PUBLIC_EDIT_ENABLED
ARG _NEXT_PUBLIC_VEO_ENABLED
ARG _NEXT_PUBLIC_VEO_ITV_ENABLED
ARG _NEXT_PUBLIC_VEO_ADVANCED_ENABLED
ARG _NEXT_PUBLIC_PRINCIPAL_TO_USER_FILTERS
ARG _NEXT_PUBLIC_OUTPUT_BUCKET
ARG _NEXT_PUBLIC_TEAM_BUCKET
ARG _NEXT_PUBLIC_GCS_UPLOAD_BUCKET
ARG _NEXT_PUBLIC_EXPORT_FIELDS_OPTIONS_URI
ARG _NEXT_PUBLIC_VTO_ENABLED

# 将接收到的 ARG 设置为构建环境中的 ENV
ENV NEXT_PUBLIC_FIREBASE_API_KEY=$_NEXT_PUBLIC_FIREBASE_API_KEY
ENV NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN=$_NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN
ENV NEXT_PUBLIC_PROJECT_ID=$_NEXT_PUBLIC_PROJECT_ID
ENV NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET=$_NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET
ENV NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID=$_NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID
ENV NEXT_PUBLIC_FIREBASE_APP_ID=$_NEXT_PUBLIC_FIREBASE_APP_ID
ENV NEXT_PUBLIC_VERTEX_API_LOCATION=$_NEXT_PUBLIC_VERTEX_API_LOCATION
ENV NEXT_PUBLIC_GCS_BUCKET_LOCATION=$_NEXT_PUBLIC_GCS_BUCKET_LOCATION
ENV NEXT_PUBLIC_GEMINI_MODEL=$_NEXT_PUBLIC_GEMINI_MODEL
ENV NEXT_PUBLIC_SEG_MODEL=$_NEXT_PUBLIC_SEG_MODEL
ENV NEXT_PUBLIC_EDIT_ENABLED=$_NEXT_PUBLIC_EDIT_ENABLED
ENV NEXT_PUBLIC_VEO_ENABLED=$_NEXT_PUBLIC_VEO_ENABLED
ENV NEXT_PUBLIC_VEO_ITV_ENABLED=$_NEXT_PUBLIC_VEO_ITV_ENABLED
ENV NEXT_PUBLIC_VEO_ADVANCED_ENABLED=$_NEXT_PUBLIC_VEO_ADVANCED_ENABLED
ENV NEXT_PUBLIC_PRINCIPAL_TO_USER_FILTERS=$_NEXT_PUBLIC_PRINCIPAL_TO_USER_FILTERS
ENV NEXT_PUBLIC_OUTPUT_BUCKET=$_NEXT_PUBLIC_OUTPUT_BUCKET
ENV NEXT_PUBLIC_TEAM_BUCKET=$_NEXT_PUBLIC_TEAM_BUCKET
ENV NEXT_PUBLIC_GCS_UPLOAD_BUCKET=$_NEXT_PUBLIC_GCS_UPLOAD_BUCKET
ENV NEXT_PUBLIC_EXPORT_FIELDS_OPTIONS_URI=$_NEXT_PUBLIC_EXPORT_FIELDS_OPTIONS_URI
ENV NEXT_PUBLIC_VTO_ENABLED=$_NEXT_PUBLIC_VTO_ENABLED

# 运行 Next.js 构建
RUN npm run build

# --- 阶段 3: 生产运行 ---
FROM base AS runner
WORKDIR /app
ENV NODE_ENV production

# 以 root 用户安装系统依赖
USER root
# 使用 apt-get 安装 ffmpeg
RUN apt-get update && apt-get install -y --no-install-recommends ffmpeg && rm -rf /var/lib/apt/lists/*

# 从 builder 阶段拷贝 standalone 输出和资源
COPY --from=builder --chown=node:node /app/.next/standalone ./
COPY --from=builder --chown=node:node /app/public ./public
COPY --from=builder --chown=node:node /app/.next/static ./.next/static

# [关键修复] 在切换用户前，将整个 /app 目录的所有权交给 node 用户
# 这样 node 用户就有权限在 /app 内创建 node_modules 和写入 package-lock.json
RUN chown -R node:node /app

# 切换回非 root 用户，增强安全性
USER node

# 为 standalone 模式单独安装 sharp
# 现在 node 用户有权限执行此操作
RUN npm install --production sharp

EXPOSE 3000

# 设置环境变量，让 Node.js 代码能找到 ffmpeg
ENV FFMPEG_PATH=/usr/bin/ffmpeg
ENV FFPROBE_PATH=/usr/bin/ffprobe

# 使用 standalone 模式的标准启动命令
CMD ["node", "server.js"]
